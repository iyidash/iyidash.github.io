[ { "title": "TITLE", "url": "/posts/ripples-without-rendertexture/", "categories": "blogging, test", "tags": "test", "date": "2022-03-20 17:30:00 +0800", "snippet": "简易水波纹（不使用RenderTexture和粒子系统） 简易水波的生成只需要 中心位置 信息即可，其余美术效果可以在shader里实现。 由于shader不能暂存信息，所以需要脚本将角色位置信息传递过来 （geometry shader 可以暂存信息？）aaaa 实现方式 Custom FunctionCustom Function代码参考 Script代码参考 参考效果 拓展波光粼粼 Shadergraph波光粼粼参考效果实现方式： 将角色位置以一定时间间隔储存到一个数组中 Vector4 waterRipples[] 将单个水波纹存活时间储存在 waterRipples.w 中 （时间最好需要考虑到角色是否移动，跳跃等） 将 waterRipples 传递给 Shader 在shader里计算所有水波纹即可 Custom Fuction： 单个水波纹代码如下： float RipplesTransform(float time, float3 positionWS, float4 center, float radius = 3, float speed = 0.5, float noise = 0){ float dist = distance((center.xyz + float3(0, 0.5, 0)), (positionWS + noise) * float3(1, 1, 2)); float changingRadius = center.w; changingRadius = 1 - changingRadius; changingRadius = 1 - pow(changingRadius,3); float opacity = sin(changingRadius * 3.1415926); float rings = abs(frac(dist - (time * speed)) - 0.5) * 2.0; rings = pow(rings,4); float mask = RemapFloat01(dist, float2(0, radius * changingRadius)); mask = 1.0 - mask; mask *= opacity; return rings * mask;} dist是到中心点的距离，其中float3(0, .5, 0)是中心点的高度偏移，用来调整水波中心位置的高度；float3(1, 1, 2)是用来缩放z方向上的距离，这样得到的就是一个椭圆形的水波（如果角色不在z轴为0的平面上的话不可以直接使用） RemapFloat01()将一个范围映射到01（自定义） changingRadius为一个0到1的值，用来控制半径变化以及透明度。 半径大小的变化需要先快后慢（蓝色曲线），透明度也是需要先快后慢最后消失（橙色曲线）。 rings就是通过frac和abs来做循环 void SetWaterRipples()用来执行计算和输出结果到shadergraph。 void SetWaterRipple_float( float3 posWS, float time, float noise, out float WaterRipples){ for (int i = 0; i &amp;lt; _ripplesParticlesSize; i++) { WaterRipples = lerp(RipplesTransform(time, posWS, _waterRipples[i], 7, 0.36, noise), 1, WaterRipples); }} Custom Function参考代码如下：//-----Unity ShaderGraph Custom Function-----uniform float4 _waterRipples[10];uniform int _ripplesParticlesSize;float RemapFloat01(float In, float2 InMinMax){ return clamp((In - InMinMax.x) / (InMinMax.y - InMinMax.x), 0, 1);}//generate according to center posfloat RipplesTransform(float time, float3 positionWS, float4 center, float radius = 3, float speed = 0.5, float noise = 0){ float dist = distance((center.xyz + float3(0, 0.5, 0)), (positionWS + noise * .7) * float3(1, 1, 2)); float changingRadius = center.w; changingRadius = 1 - changingRadius; changingRadius = 1 - pow(changingRadius,3); float opacity = sin(changingRadius * 3.1415926); float rings = abs(frac(dist - (time * speed)) - 0.5) * 2.0; rings = pow(rings,4); float mask = RemapFloat01(dist, float2(0, radius * changingRadius)); mask = 1.0 - mask; mask *= opacity; return rings * mask;}void SetWaterRipple_float( float3 posWS, float time, float noise, out float WaterRipples){ for (int i = 0; i &amp;lt; _ripplesParticlesSize; i++) { WaterRipples = lerp(RipplesTransform(time, posWS, _waterRipples[i], 7, 0.36, noise), 1, WaterRipples); }}Script： ripplesParticlesSize和waterRipples[]需要传入shader。其中waterRipples[].xyz代表水波的中心位置，waterRipples[].w代表水波的存活时间； waterRipples[].w可以被time_dissolving 和 time_jumping影响到，time_jumping由time_grounded和time_air决定。 这样一来waterRipples[].w的值就可以大致用来表示角色在运动时、起跳时、在空中时以及落地时的不同状态。 参考代码如下：//-----C# Script-----public class SetWaterRipples : MonoBehaviour{ private static int ripplesParticlesSize = 9; private int count; private Vector4[] waterRipples = new Vector4[ripplesParticlesSize]; private bool[] startSpreading = new bool[ripplesParticlesSize]; private float[] time_ripple = new float[ripplesParticlesSize]; [SerializeField] private float interval = .2f; private float duration; private float time; private float time_dissolving; private Transform playerTr; private Vector3 playerPos; private CharacterMovement _characterMovement; private Controller _controller; void Start() { playerTr = GameObject.FindWithTag(&quot;Player&quot;).transform; _characterMovement = playerTr.gameObject.GetComponent&amp;lt;CharacterMovement&amp;gt;(); _controller = playerTr.gameObject.GetComponent&amp;lt;Controller&amp;gt;(); duration = (ripplesParticlesSize) * interval; Shader.SetGlobalInt(&quot;_ripplesParticlesSize&quot;, ripplesParticlesSize); for (int i = 0; i &amp;lt; ripplesParticlesSize; i++) { startSpreading[i] = false; } } void Update() { playerPos = playerTr.position; Timer(); if (time &amp;gt;= interval) { waterRipples[count] = playerPos + new Vector3(Random.Range(-.3f, .3f), 0f, Random.Range(-1f, 1f)); startSpreading[count] = true; count++; if (count &amp;gt; ripplesParticlesSize-1) { count = 0; } time = 0f; } Shader.SetGlobalVectorArray(&quot;_waterRipples&quot;, waterRipples); } private bool isGrounded = false; private float time_grounded; private float time_air; private float time_jumping; void Timer() { time += Time.deltaTime; for (int i = 0; i &amp;lt; ripplesParticlesSize; i++) { if (startSpreading[i]) { time_ripple[i] += Time.deltaTime; //combination of ripple appreance waterRipples[i].w = Mathf.Clamp01(Mathf.InverseLerp(0f, duration, time_ripple[i])) * Mathf.Lerp(time_dissolving, 1f, (1f - time_jump) * Mathf.Sin(Mathf.PI * (1f - Mathf.Pow((1f - time_jump), 3f)) )); if (time_ripple[i] &amp;gt;= duration) { startSpreading[i] = false; time_ripple[i] = 0f; } } } //appear when jumping isGrounded = _controller.State.IsGrounded; if (isGrounded) { time_air = 0f; time_grounded += Time.deltaTime * .6f; if (time_grounded &amp;gt;= 1f) { time_grounded = 1f; } } else { time_grounded = 0f; time_air += Time.deltaTime * 1f; if (time_air &amp;gt;= 1f) { time_air = 1f; } } time_jumping = Mathf.Lerp(time_grounded, 1f, time_air); //appear when moving if (_characterMovement._horizontalMovement != 0f) { time_dissolving += Time.deltaTime * 1f; if (time_dissolving &amp;gt;= 1f) { time_dissolving = 1f; } } else { time_dissolving -= Time.deltaTime * 0.3f; if (time_dissolving &amp;lt;= 0f) { time_dissolving = 0f; } } }}拓展: 水面添加波光粼粼效果波光粼粼效果近处比较少，远处比较明显。可以使用 positionWS.z 结合 Screen Position 最后添加噪波等完成（下面是屏幕空间近小远大参考） 波光效果：Final Shadergraph： " }, { "title": "ShaderGraph实现", "url": "/posts/Shader%E5%AE%9E%E7%8E%B02D%E4%BA%BA%E7%BE%A4%E5%8A%A8%E7%94%BB/", "categories": "blogging, test", "tags": "test", "date": "2022-03-20 17:30:00 +0800", "snippet": "ShaderGraph实现2D人群动画 通过 uv 结合帧动画等方式实现状态不一的人群，例如高低不同，颜色不同，帧动画播放速度不同，人群间隔不同等，并且可以通过 linerenderer 来规划路径。局限：在平面上效果最佳，且不能有太大的倾斜角度 实现方式uv.x设置间隔设置sprite sheet设置 拓展testA 用以前画的一段序列动画来做演示，颜色随机和高低以及速度等没有设置很明显。 3:::::实现方式： 最重要的一点是利用世界坐标x的值来作为uv.x值。其余效果大致从这展开。testB 将世界坐标的x轴作为uv.x，uv.y暂时先保持不变。这样就可以做到随意改变宽度却不影响列数。 因为uv.y不变所以可以使用 linerenderer 来做上下坡的效果。 对上一步得到的uv.x取模后作为透明通道就可以用来表现间隔（记得取绝对值） 添加序列动画需要对uv.y进行修改。该方法建议sprite sheet的行数为1（行数不为1的话间隔要是2的倍数才行）。可以通过取模等简单计算得到序列帧动画。 拓展：用实现方法1. 中得到的u取整做随机再通过lerp可以对该shader中的各种值做随机，从而模拟人群（或物体）的随机感。因为u是取整后再做随机，所以能保证每一列各自分配到一个随机值。例如： 在v做各种计算前就可以做随机高度缩放（缩放的程度取决于sprite sheet中每一帧上方的空白有多少） sprite sheet可以用这个添加一个偏移使得播放顺序以及速度不一致 同理间隔和颜色也可以随机 每个实例还可以根据世界位置信息来做偏移和随机。可以使用object position，不过在使用linerenderer的时候不可以，因为其object position为世界坐标原点 (0, 0, 0) 。 在使用linerenderer时可以直接使用world position 的z来做偏移或随机，前提是这些物体和z轴同一方向（有时可能会出现闪烁，尤其是在相机改变焦距或者发生z方向位移时。解决方法：floor或ceil(a*positionWS.z) 使用linerenderer的好处是可以编辑路径，且操作方便，但是处理随机不太方便。 可以根据需求做一个简单的模型，并使用vertex color来做顶点位移的遮罩。这样就可以实现简单的上下坡，甚至朝向与z轴偏一些也有不错的效果。 最后整合后的shadergraph： " } ]
